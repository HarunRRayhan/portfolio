#!/bin/bash

# Usage:
#   ./deploy.sh [KEY=VALUE ...]
#   Example: ./deploy.sh APP_DEBUG=true FOO=bar
# Any key=value pairs passed as arguments will take highest priority in the generated .env file.
# The .env file is generated by merging, in order of precedence (lowest to highest):
#   1. .env.example (base)
#   2. deploy/.env.appprod (if exists)
#   3. deploy/.env.deploy (if exists)
#   4. Inline key=value arguments (provided at runtime)

# Set up logging
LOG_DIR="$(dirname "$0")/log"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/deploy-$(date '+%Y%m%d-%H%M%S').log"
exec > >(tee -a "$LOG_FILE") 2>&1

# Load environment variables
if [ -f "$(dirname "$0")/.env.deploy" ]; then
  set -a
  . "$(dirname "$0")/.env.deploy"
  set +a
fi

# Ensure SSH_KEY is relative to the deploy directory
if [ -n "$SSH_KEY" ] && [[ "$SSH_KEY" != /* ]]; then
  SSH_KEY="$(cd "$(dirname "$0")" && pwd)/$SSH_KEY"
fi

echo "[DEBUG] SSH_KEY resolved to: $SSH_KEY"

# Configuration
# REMOTE_USER, REMOTE_HOST, SSH_KEY, APP_DIR are now loaded from .env.deploy

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# Function to execute SSH commands
execute_ssh() {
    ssh -o StrictHostKeyChecking=no -i "$SSH_KEY" "$REMOTE_USER@$REMOTE_HOST" "$1"
}

# Function to clone or update the git repository on the server
clone_or_update_repo() {
    execute_ssh "if [ ! -d $APP_DIR/.git ]; then \
        if [ -d $APP_DIR ]; then \
            rm -rf $APP_DIR/* $APP_DIR/.[!.]* $APP_DIR/..?* 2>/dev/null || true; \
        else \
            mkdir -p $APP_DIR; \
        fi; \
        git clone --branch $GIT_BRANCH $GIT_REPO $APP_DIR; \
    else \
        cd $APP_DIR && git fetch origin && git checkout $GIT_BRANCH && git pull origin $GIT_BRANCH; \
    fi"
}

# Function to robustly merge env files
merge_env_files() {
    # $1 = base file, $2 = override file, $3 = output file
    cp "$1" "$3"
    if [ -f "$2" ]; then
        while IFS= read -r line; do
            # Only process non-empty, non-comment lines
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                key="${line%%=*}"
                # Remove any existing key (even if commented out)
                sed -i '' "/^$key=/d" "$3"
                # Append the new/override value
                echo "$line" >> "$3"
            fi
        done < "$2"
    fi
}

# Helper: Overlay only inline-provided envs (those set on the command line)
overlay_inline_envs() {
    # Save current IFS
    OLDIFS=$IFS
    IFS=' '
    # Get the list of inline envs from the command line
    for arg in $(ps -o args= -p $$); do
        if [[ "$arg" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
            key="${arg%%=*}"
            value="${arg#*=}"
            sed -i '' "/^$key=/d" ".env"
            echo "$key=$value" >> ".env"
        fi
    done
    IFS=$OLDIFS
}

echo -e "${GREEN}Starting deployment...${NC}"

# Fix permissions on the server before anything else
echo -e "${GREEN}Fixing permissions on server...${NC}"
execute_ssh "sudo chown -R ubuntu:ubuntu $APP_DIR || true"

# Ensure ubuntu user is in the docker group for Docker access
echo -e "${GREEN}Ensuring ubuntu user is in the docker group...${NC}"
execute_ssh "sudo usermod -aG docker ubuntu"

echo -e "${GREEN}Generating .env file from .env.example, .env.appprod, and deploy variables...${NC}"

# Always start from .env.example
merge_env_files "../.env.example" "$(dirname "$0")/.env.appprod" ".env"
# Overlay with deploy/.env.deploy variables (if any)
merge_env_files ".env" "$(dirname "$0")/.env.deploy" ".env"
# Overlay with any key=value arguments passed to the script (highest priority)
for arg in "$@"; do
    if [[ "$arg" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
        key="${arg%%=*}"
        value="${arg#*=}"
        grep -v "^$key=" .env > .env.tmp && mv .env.tmp .env
        echo "$key=$value" >> .env
    fi
done

# Ensure resources/views exists with a real Blade placeholder for Laravel
mkdir -p ../resources/views
if [ ! -f ../resources/views/placeholder.blade.php ]; then
  echo "{{-- Placeholder view to satisfy Laravel --}}" > ../resources/views/placeholder.blade.php
fi

# Build frontend locally and zip assets
echo -e "${GREEN}Building frontend locally...${NC}"
cd .. && npm ci && npm run build && cd deploy
zip -r public-build.zip ../public/build

# Clone or update repo on server
echo -e "${GREEN}Cloning or updating repository on server...${NC}"
clone_or_update_repo

# Upload local build assets
echo -e "${GREEN}Uploading built frontend assets...${NC}"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" public-build.zip "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/public-build.zip"

# Extract on server
echo -e "${GREEN}Extracting frontend assets on server...${NC}"
execute_ssh "unzip -o $APP_DIR/public-build.zip -d $APP_DIR/public/"

# Copy .env file
echo -e "${GREEN}Copying .env file...${NC}"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" .env "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/.env"

# Upload and extract build artifacts before Docker Compose
echo -e "${GREEN}Uploading build-artifact.zip to server...${NC}"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" "$(dirname "$0")/build-artifact.zip" "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/build-artifact.zip"
echo -e "${GREEN}Installing unzip on server if needed...${NC}"
execute_ssh "sudo apt-get update && sudo apt-get install -y unzip"
echo -e "${GREEN}Extracting build-artifact.zip on server...${NC}"
execute_ssh "unzip -o $APP_DIR/build-artifact.zip -d $APP_DIR/"

# Generate SSL cert and key on the server if not present
SSL_PATH="/etc/nginx/ssl"
SSL_CRT="$SSL_PATH/harun.dev.crt"
SSL_KEY="$SSL_PATH/harun.dev.key"
echo -e "${GREEN}Ensuring SSL certificate and key exist on server...${NC}"
execute_ssh "sudo mkdir -p $SSL_PATH && \
  if [ ! -f $SSL_CRT ] || [ ! -f $SSL_KEY ]; then \
    sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
      -keyout $SSL_KEY -out $SSL_CRT \
      -subj '/CN=harun.dev'; \
    sudo chmod 600 $SSL_CRT $SSL_KEY && sudo chown root:root $SSL_CRT $SSL_KEY; \
  fi"

# Ensure required Laravel cache and storage directories exist and are writable by www-data
execute_ssh "cd $APP_DIR && \
  mkdir -p storage/framework/views storage/framework/cache storage/logs bootstrap/cache && \
  sudo chown -R www-data:www-data storage bootstrap/cache && \
  sudo chmod -R 775 storage bootstrap/cache"

# Wait for the database to be ready inside the app container before migrations
execute_ssh "cd $APP_DIR && docker-compose -f docker/docker-compose.yml exec -T app ./wait-for-db.sh db 5432 60"

# Ensure correct permissions on host before up
sudo chown -R 82:82 storage bootstrap/cache
sudo chmod -R 775 storage bootstrap/cache

# Execute deployment commands
echo -e "${GREEN}Executing deployment commands...${NC}"
execute_ssh "cd $APP_DIR && \
    docker-compose -f docker/docker-compose.yml down && \
    docker-compose -f docker/docker-compose.yml build --no-cache && \
    docker-compose -f docker/docker-compose.yml up -d && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan key:generate --force && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan config:cache && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan route:cache && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan view:cache && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan migrate --force && \
    docker-compose -f docker/docker-compose.yml exec -T app php artisan storage:link && \
    docker-compose -f docker/docker-compose.yml exec -T app chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache && \
    docker-compose -f docker/docker-compose.yml exec -T app chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache"

echo -e "${GREEN}Deployment completed!${NC}"
