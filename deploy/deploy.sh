#!/bin/bash

set -e
set -o pipefail

# Get absolute path to script directory, regardless of where it's called from
SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"

# Usage:
#   ./deploy.sh [KEY=VALUE ...]
#   Example: ./deploy.sh APP_DEBUG=true FOO=bar
# Any key=value pairs passed as arguments will take highest priority in the generated .env file.
# The .env file is generated by merging, in order of precedence (lowest to highest):
#   1. .env.example (base)
#   2. deploy/.env.appprod (if exists)
#   3. deploy/.env.deploy (if exists)
#   4. Inline key=value arguments (provided at runtime)

# Set up logging
LOG_DIR="$SCRIPT_DIR/log"
mkdir -p "$LOG_DIR"
# Archive previous deploy.log if it exists
if [ -f "$LOG_DIR/deploy.log" ]; then
  mv "$LOG_DIR/deploy.log" "$LOG_DIR/deploy-$(date '+%Y%m%d-%H%M%S').log"
fi
LOG_FILE="$LOG_DIR/deploy.log"
exec > >(tee -a "$LOG_FILE") 2>&1

# Load environment variables
if [ -f "$SCRIPT_DIR/.env.deploy" ]; then
  set -a
  . "$SCRIPT_DIR/.env.deploy"
  set +a
fi

# Ensure SSH_KEY is relative to the deploy directory
if [ -n "$SSH_KEY" ] && [[ "$SSH_KEY" != /* ]]; then
  SSH_KEY="$SCRIPT_DIR/$SSH_KEY"
fi

echo "[DEBUG] SSH_KEY resolved to: $SSH_KEY"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# Signature and start time
SCRIPT_START_TIME=$(date +%s)
echo -e "\n\033[1;35m==============================================="
echo -e "   ðŸš€ Harun's Portfolio Deployment Script ðŸš€"
echo -e "===============================================\033[0m\n"
echo "Started at: $(date)"

# Remove associative array, use indexed array for step times
STEP_TIMES=()

# Helper: Print step header, track and print step time
step() {
  STEP_NUM=$1
  STEP_NAME="$2"
  echo -e "\n\033[1;36m++++++++++++++++++++++++++++++++++++++++++++++"
  printf '+++   STEP %d: %s   +++\n' "$STEP_NUM" "$STEP_NAME"
  echo -e "++++++++++++++++++++++++++++++++++++++++++++++\033[0m\n"
  STEP_START_TIME=$(date +%s)
}

# Helper: Print success info to terminal only
success() {
  echo -e "\033[0;32m$1\033[0m"
  STEP_END_TIME=$(date +%s)
  STEP_DURATION=$((STEP_END_TIME - STEP_START_TIME))
  echo -e "\033[0;33mStep took $STEP_DURATION seconds.\033[0m\n"
  STEP_TIMES+=("$STEP_DURATION")
}

# Helper: Print error info to terminal only
fail() {
  echo -e "\033[0;31m$1\033[0m"
  STEP_END_TIME=$(date +%s)
  STEP_DURATION=$((STEP_END_TIME - STEP_START_TIME))
  echo -e "\033[0;33mStep took $STEP_DURATION seconds.\033[0m\n"
  STEP_TIMES+=("$STEP_DURATION")
}

# At the end, print total time
print_total_time() {
  SCRIPT_END_TIME=$(date +%s)
  TOTAL_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
  echo -e "\n\033[1;35m==============================================="
  echo -e "   ðŸŽ‰ Deployment completed in $TOTAL_DURATION seconds! ðŸŽ‰"
  echo -e "===============================================\033[0m\n"
  for i in $(seq 1 ${#STEP_TIMES[@]}); do
    echo "Step $i took: ${STEP_TIMES[$((i-1))]:-N/A} seconds"
  done
}

# Function to execute SSH commands
execute_ssh() {
    ssh -o StrictHostKeyChecking=no -i "$SSH_KEY" "$REMOTE_USER@$REMOTE_HOST" "$1"
}

# Function to clone or update the git repository on the server
clone_or_update_repo() {
    execute_ssh "if [ ! -d $APP_DIR/.git ]; then \
        if [ -d $APP_DIR ]; then \
            rm -rf $APP_DIR/* $APP_DIR/.[!.]* $APP_DIR/..?* 2>/dev/null || true; \
        else \
            mkdir -p $APP_DIR; \
        fi; \
        git clone --branch $GIT_BRANCH $GIT_REPO $APP_DIR; \
    else \
        cd $APP_DIR && git fetch origin && git checkout $GIT_BRANCH && git pull origin $GIT_BRANCH; \
    fi"
}

# Function to robustly merge env files
merge_env_files() {
    # $1 = base file, $2 = override file, $3 = output file
    if ! cmp -s "$1" "$3"; then
        cp "$1" "$3"
    fi
    if [ -f "$2" ]; then
        while IFS= read -r line; do
            # Only process non-empty, non-comment lines
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                key="${line%%=*}"
                # Remove any existing key (even if commented out)
                sed -i '' "/^$key=/d" "$3"
                # Append the new/override value
                echo "$line" >> "$3"
            fi
        done < "$2"
    fi
}

# Helper: Overlay only inline-provided envs (those set on the command line)
overlay_inline_envs() {
    # Save current IFS
    OLDIFS=$IFS
    IFS=' '
    # Get the list of inline envs from the command line
    for arg in $(ps -o args= -p $$); do
        if [[ "$arg" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
            key="${arg%%=*}"
            value="${arg#*=}"
            sed -i '' "/^$key=/d" "$SCRIPT_DIR/.env"
            echo "$key=$value" >> "$SCRIPT_DIR/.env"
        fi
    done
    IFS=$OLDIFS
}

# Add this helper function near the top of the script
wait_for_app_container() {
  local timeout=60
  local elapsed=0
  while [ $elapsed -lt $timeout ]; do
    STATUS=$(execute_ssh "cd $APP_DIR && docker-compose -f ./docker/docker-compose.yml ps --services --filter 'status=running' | grep '^app$'")
    if [ "$STATUS" = "app" ]; then
      return 0
    fi
    sleep 2
    elapsed=$((elapsed+2))
  done
  echo "App container did not start within $timeout seconds." >&2
  return 1
}

# 1. Start
step 1 "Starting deployment"
echo "[DEBUG] SSH_KEY resolved to: $SSH_KEY"

# 2. Fix permissions on the server before anything else
step 2 "Fixing permissions on server"
execute_ssh "sudo chown -R ubuntu:ubuntu $APP_DIR || true"

# 3. Ensure ubuntu user is in the docker group for Docker access
step 3 "Ensuring ubuntu user is in the docker group"
execute_ssh "sudo usermod -aG docker ubuntu"

# 4. Generate .env file from .env.example, .env.appprod, and deploy variables
step 4 "Generating .env file from .env.example, .env.appprod, and deploy variables"
merge_env_files "$REPO_ROOT/.env.example" "$SCRIPT_DIR/.env.appprod" "$SCRIPT_DIR/.env"
merge_env_files "$SCRIPT_DIR/.env" "$SCRIPT_DIR/.env.deploy" "$SCRIPT_DIR/.env"
for arg in "$@"; do
    if [[ "$arg" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
        key="${arg%%=*}"
        value="${arg#*=}"
        grep -v "^$key=" "$SCRIPT_DIR/.env" > "$SCRIPT_DIR/.env.tmp" && mv "$SCRIPT_DIR/.env.tmp" "$SCRIPT_DIR/.env"
        echo "$key=$value" >> "$SCRIPT_DIR/.env"
    fi
done

# 5. Ensure resources/views exists with a real Blade placeholder for Laravel
step 5 "Ensuring resources/views exists with placeholder"
mkdir -p "$REPO_ROOT/resources/views"
if [ ! -f "$REPO_ROOT/resources/views/placeholder.blade.php" ]; then
  echo "{{-- Placeholder view to satisfy Laravel --}}" > "$REPO_ROOT/resources/views/placeholder.blade.php"
fi

# 6. Check Node.js version before build
step 6 "Checking Node.js version"

# Check if nvm is installed
if ! command -v nvm &> /dev/null; then
  echo "nvm not found, attempting to source from common locations..."

  # Try to source nvm from common locations
  if [ -s "$HOME/.nvm/nvm.sh" ]; then
    . "$HOME/.nvm/nvm.sh"
  elif [ -s "$NVM_DIR/nvm.sh" ]; then
    . "$NVM_DIR/nvm.sh"
  elif [ -s "/usr/local/opt/nvm/nvm.sh" ]; then
    . "/usr/local/opt/nvm/nvm.sh"
  fi

  # Check again after sourcing
  if ! command -v nvm &> /dev/null; then
    echo "Installing nvm..."
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash

    # Source nvm after installation
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  fi
fi

# Check Node.js version
NODE_VERSION=$(node -v 2>/dev/null | sed 's/v//;s/\..*//' || echo "0")
if [ "$NODE_VERSION" -lt 18 ]; then
  echo "Node.js >= 18 is required. Current: $(node -v 2>/dev/null || echo 'not installed')"

  if command -v nvm &> /dev/null; then
    echo "Attempting to switch to Node.js LTS using nvm..."
    nvm install --lts
    nvm use --lts

    # Check version again after nvm use
    NODE_VERSION=$(node -v | sed 's/v//;s/\..*//')
    if [ "$NODE_VERSION" -lt 18 ]; then
      fail "Failed to switch to Node.js >= 18 using nvm. Please install Node.js >= 18 manually."
      exit 1
    else
      echo "Successfully switched to Node.js $(node -v) using nvm."
    fi
  else
    fail "nvm is not available after installation attempt. Please install Node.js >= 18 manually."
    exit 1
  fi
fi

# 7. Build frontend locally and zip assets
step 7 "Building frontend locally"
cd "$REPO_ROOT" && npm ci && npm run build
BUILD_STATUS=$?
cd "$SCRIPT_DIR"
if [ $BUILD_STATUS -ne 0 ]; then
  fail "Frontend build failed. Aborting deploy."
  exit 1
fi
rm -f "$SCRIPT_DIR/public-build.zip"
(cd "$REPO_ROOT/public" && zip -r "$SCRIPT_DIR/public-build.zip" build > /dev/null 2>&1)

# 8. Clone or update repo on server
step 8 "Cloning or updating repository on server"
clone_or_update_repo

# 9. Ensure host storage directory has correct structure and permissions (after clone)
step 9 "Ensuring host storage directory structure and permissions"
HOST_STORAGE_DIR="/opt/portfolio/storage"
execute_ssh "if [ -d '$HOST_STORAGE_DIR' ]; then \
  mkdir -p '$HOST_STORAGE_DIR/framework/views' '$HOST_STORAGE_DIR/framework/cache' '$HOST_STORAGE_DIR/logs'; \
  sudo chown -R 82:82 '$HOST_STORAGE_DIR'; \
  sudo chmod -R 775 '$HOST_STORAGE_DIR'; \
else \
  echo '[WARN] Host storage directory $HOST_STORAGE_DIR does not exist!'; \
fi"

# 10. Upload local build assets
step 10 "Uploading built frontend assets"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" "$SCRIPT_DIR/public-build.zip" "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/public-build.zip"
execute_ssh "ls -lh $APP_DIR/public-build.zip && echo '[DEBUG] Uploaded public-build.zip to: $APP_DIR/public-build.zip'"

# 11. Install unzip on server if needed
step 11 "Installing unzip on server if needed"
execute_ssh "sudo apt-get update && sudo apt-get install -y unzip"

# 12. Extract frontend assets
step 12 "Extracting frontend assets from zip file"
execute_ssh "mkdir -p $APP_DIR/public && cd $APP_DIR && unzip -o public-build.zip -d public && ls -la public/build && echo '[DEBUG] Extracted frontend assets to public/build'"

# 13. Set up docker env on the server & start containers
step 13 "Setting up docker environment on server & starting containers"
execute_ssh "mkdir -p $APP_DIR/docker $APP_DIR/bootstrap/cache $APP_DIR/storage $APP_DIR/storage/logs $APP_DIR/storage/framework/sessions $APP_DIR/storage/framework/views $APP_DIR/storage/framework/cache"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" "$SCRIPT_DIR/docker/docker-compose.yml" "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/docker/docker-compose.yml"

# 14. Copy .env file
step 14 "Copying .env file"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" "$SCRIPT_DIR/.env" "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/.env"
scp -o StrictHostKeyChecking=no -i "$SSH_KEY" "$SCRIPT_DIR/.env" "$REMOTE_USER@$REMOTE_HOST:$APP_DIR/docker/.env"

# 15. Generate SSL cert and key on the server if not present
step 15 "Ensuring SSL certificate and key exist on server"
SSL_PATH="/etc/nginx/ssl"
SSL_CRT="$SSL_PATH/harun.dev.crt"
SSL_KEY="$SSL_PATH/harun.dev.key"
execute_ssh "sudo mkdir -p $SSL_PATH && \
  if [ ! -f $SSL_CRT ] || [ ! -f $SSL_KEY ]; then \
    sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
      -keyout $SSL_KEY -out $SSL_CRT \
      -subj '/CN=harun.dev'; \
    sudo chmod 600 $SSL_CRT $SSL_KEY && sudo chown root:root $SSL_CRT $SSL_KEY; \
  fi"

# 16. Ensure required Laravel cache and storage directories exist and are writable by www-data
step 16 "Ensuring Laravel cache and storage directories exist and are writable"
execute_ssh "cd $APP_DIR && \
  mkdir -p storage/framework/views storage/framework/cache storage/logs bootstrap/cache && \
  sudo chown -R www-data:www-data storage bootstrap/cache && \
  sudo chmod -R 775 storage bootstrap/cache"

# 17. Execute deployment commands
step 17 "Executing deployment commands"
# The app container will wait for the db container to be healthy due to 'depends_on' and healthcheck in docker-compose.yml
execute_ssh "cd $APP_DIR && \
    docker-compose -f ./docker/docker-compose.yml down && \
    docker-compose -f ./docker/docker-compose.yml build --no-cache && \
    POSTGRES_DB=$POSTGRES_DB POSTGRES_USER=$POSTGRES_USER POSTGRES_PASSWORD=$POSTGRES_PASSWORD docker-compose -f ./docker/docker-compose.yml up -d && \
    touch .env && chmod 666 .env && \
    docker-compose -f ./docker/docker-compose.yml ps | grep app && \
    APP_KEY=\$(docker-compose -f ./docker/docker-compose.yml exec -T app php artisan key:generate --show) && \
    echo \"Found APP_KEY: \$APP_KEY\" && \
    grep -q \"^APP_KEY=\" .env && sed -i \"s|^APP_KEY=.*|\$APP_KEY|\" .env || echo \"\$APP_KEY\" >> .env && \
    docker-compose -f ./docker/docker-compose.yml exec -T app php artisan config:cache && \
    docker-compose -f ./docker/docker-compose.yml exec -T app php artisan route:cache && \
    docker-compose -f ./docker/docker-compose.yml exec -T app php artisan view:cache && \
    docker-compose -f ./docker/docker-compose.yml exec -T app php artisan migrate --force && \
    docker-compose -f ./docker/docker-compose.yml exec -T app php artisan storage:link && \
    docker-compose -f ./docker/docker-compose.yml exec -T app chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache && \
    docker-compose -f ./docker/docker-compose.yml exec -T app chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache"

# 18. Check app container status
step 18 "Checking app container status"
if ! wait_for_app_container; then
  fail "App container did not start in time. Aborting deploy."
  exit 1
fi

# 19. Ensure wait-for-db.sh is executable in the container
step 19 "Ensuring wait-for-db.sh is executable in the container"
execute_ssh "cd $APP_DIR && docker-compose -f ./docker/docker-compose.yml exec -T app chmod +x ./wait-for-db.sh"

# 20. Wait for the database to be ready
step 20 "Waiting for the database to be ready inside the app container"
execute_ssh "cd $APP_DIR && docker-compose -f ./docker/docker-compose.yml exec -T app ./wait-for-db.sh db 5432 60"

# 21 Test DB connection from app container
step 21 "Testing database connection from app container"
execute_ssh "cd $APP_DIR && docker-compose -f ./docker/docker-compose.yml exec -T app php artisan migrate:status"

success "Deployment completed!"

# 22. Purge CDN Cache (Cloudflare)
step 22 "Purging CDN Cache (Cloudflare)"
if [ -z "$CLOUDFLARE_ZONE_ID" ] || [ -z "$CLOUDFLARE_API_TOKEN" ]; then
  echo "Skipping Cloudflare CDN purge - missing CLOUDFLARE_ZONE_ID or CLOUDFLARE_API_TOKEN"
  echo "To enable Cloudflare cache purging, add the following to your .env.deploy file:"
  echo "CLOUDFLARE_ZONE_ID=your_zone_id"
  echo "CLOUDFLARE_API_TOKEN=your_api_token"
  echo "CLOUDFLARE_EMAIL=your_email@example.com (only needed for Global API Key authentication)"
else
  echo "Attempting to purge Cloudflare cache for zone ID $CLOUDFLARE_ZONE_ID"

  # Check if this is likely an API Token or a Global API Key based on length
  if [[ ${#CLOUDFLARE_API_TOKEN} -gt 35 ]]; then
    # Likely an API Token - use Bearer Authentication
    echo "Using API Token authentication method..."
    RESULT=$(curl -s -X POST \
      "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/purge_cache" \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
      -d '{"purge_everything":true}')
  else
    # Likely a Global API Key - needs email
    echo "Using Global API Key authentication method..."
    if [ -z "$CLOUDFLARE_EMAIL" ]; then
      echo "Failed to purge Cloudflare cache. Response: $RESULT"
    else
      RESULT=$(curl -s -X POST \
        "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/purge_cache" \
        -H "Content-Type: application/json" \
        -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
        -H "X-Auth-Key: $CLOUDFLARE_API_TOKEN" \
        -d '{"purge_everything":true}')
    fi
  fi

  # Check if we have a result to evaluate
  if [ -n "$RESULT" ]; then
    if echo "$RESULT" | grep -q '"success":true'; then
      echo "Cloudflare cache purged successfully!"
    else
      echo "Failed to purge Cloudflare cache. Response: $RESULT"
    fi
  fi
fi

# 22. Print total time and summary
print_total_time
